{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"go-cggmp-tss","text":"<p>A pure Go implementation of the CGGMP21 Threshold Signature Scheme (TSS) protocol.</p> <p>Note: This library is currently in active development (Alpha). Do not use in production environments without a thorough security audit.</p>"},{"location":"#overview","title":"Overview","text":"<p>This library implements the CGGMP21 protocol (Canetti-Gennaro-Goldfeder-Makriyannis-Peled), which allows a group of parties to generate a key and sign messages without ever reconstructing the private key in a single location.</p>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Protocol Compliance: Implements the 4-round Key Generation and 5-round Signing protocols from CGGMP21.</li> <li>Network Agnostic: Designed as a pure state machine. You bring your own transport layer (HTTP, gRPC, Libp2p, NATS, etc.).</li> <li>Type Safety: Leverages Go's strong typing to prevent common implementation errors.</li> <li>Curve Support: Native support for <code>secp256k1</code>.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>go get github.com/smallyu/go-cggmp-tss\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":"<p>The core of the library is the <code>StateMachine</code> pattern. Here is a high-level view of how to integrate it:</p> <pre><code>import (\n    \"github.com/smallyu/go-cggmp-tss/pkg/tss\"\n    \"github.com/smallyu/go-cggmp-tss/internal/protocol/keygen\"\n)\n\n// 1. Initialize the State Machine\nstate, outMsgs, err := keygen.NewStateMachine(params)\n\n// 2. Run the Event Loop\nfor {\n    // Receive message from your network layer\n    msg := network.Receive()\n\n    // Update the state machine\n    nextState, outMsgs, err := state.Update(msg)\n    if err != nil {\n        log.Fatal(err)\n    }\n\n    // Send output messages to other parties\n    network.Broadcast(outMsgs)\n\n    // Check for completion\n    if nextState == nil {\n        result := state.Result()\n        // Handle result (KeyShare or Signature)\n        break\n    }\n\n    state = nextState\n}\n</code></pre> <p>For a complete step-by-step guide, please read the Usage Documentation.</p>"},{"location":"#documentation","title":"Documentation","text":"<ul> <li>Usage Guide: Detailed instructions on implementing KeyGen and Signing.</li> </ul>"},{"location":"#architecture","title":"Architecture","text":"<p>The library is structured to separate cryptographic primitives from protocol logic:</p> <ul> <li><code>pkg/tss</code>: Core interfaces (<code>PartyID</code>, <code>Message</code>, <code>StateMachine</code>).</li> <li><code>internal/crypto</code>: Cryptographic primitives (Paillier, ZK Proofs, Commitments).</li> <li><code>internal/protocol</code>: Protocol implementations (<code>keygen</code>, <code>sign</code>).</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT</p>"},{"location":"ROADMAP/","title":"Roadmap","text":""},{"location":"ROADMAP/#supported-features-v005","title":"Supported Features (v0.0.5)","text":"<ul> <li>[x] Key Generation (CGGMP21 4-round)</li> <li>[x] Threshold Signing (CGGMP21 5-round)</li> <li>[x] Key Refresh (CGGMP21 4-round)</li> <li>[x] Key Resharing (Committee and threshold changes)</li> <li>[x] Presigning (Offline preprocessing for faster signing)</li> <li>[x] Identification Protocol (ZKP for key ownership)</li> <li>[x] Batch Signing</li> <li>[x] Performance Benchmarks</li> <li>[x] <code>secp256k1</code> Curve Support</li> </ul>"},{"location":"ROADMAP/#planned-features","title":"Planned Features","text":""},{"location":"ROADMAP/#phase-1-optimization","title":"Phase 1: Optimization","text":"<ul> <li>[x] 1-Round KeyGen (using simpler assumptions)</li> </ul>"},{"location":"ROADMAP/#phase-2-ecosystem","title":"Phase 2: Ecosystem","text":"<ul> <li>[ ] WebAssembly (WASM) support</li> <li>[ ] Mobile bindings (iOS/Android)</li> </ul>"},{"location":"USAGE/","title":"Usage Guide","text":"<p>This guide explains how to use the <code>go-cggmp-tss</code> library to perform Distributed Key Generation (DKG) and Threshold Signing.</p>"},{"location":"USAGE/#core-concepts","title":"Core Concepts","text":""},{"location":"USAGE/#network-agnostic","title":"Network Agnostic","text":"<p>This library is a pure computation engine. It does not handle networking, database storage, or transport security. You are responsible for: 1.  Creating a transport layer (HTTP, gRPC, Libp2p, etc.). 2.  Routing messages between parties. 3.  Persisting the state if necessary.</p>"},{"location":"USAGE/#state-machine","title":"State Machine","text":"<p>The protocol is implemented as a Finite State Machine (FSM). - Input: Incoming messages from other parties. - Output: Outgoing messages to be broadcast or sent P2P. - State: The current round of the protocol.</p>"},{"location":"USAGE/#prerequisites","title":"Prerequisites","text":""},{"location":"USAGE/#1-implement-partyid","title":"1. Implement <code>PartyID</code>","text":"<p>You need to implement the <code>tss.PartyID</code> interface to identify participants.</p> <pre><code>type MyPartyID struct {\n    IDStr   string\n    MonikerStr string\n    PubKey  []byte\n}\n\nfunc (p *MyPartyID) ID() string      { return p.IDStr }\nfunc (p *MyPartyID) Moniker() string { return p.MonikerStr }\nfunc (p *MyPartyID) Key() []byte     { return p.PubKey }\n</code></pre>"},{"location":"USAGE/#2-setup-parameters","title":"2. Setup Parameters","text":"<p>Configure the session parameters.</p> <pre><code>import \"github.com/smallyu/go-cggmp-tss/pkg/tss\"\n\n// Create party IDs\np1 := &amp;MyPartyID{IDStr: \"1\", ...}\np2 := &amp;MyPartyID{IDStr: \"2\", ...}\np3 := &amp;MyPartyID{IDStr: \"3\", ...}\n\nparams := &amp;tss.Parameters{\n    PartyID:   p1,                 // Local party\n    Parties:   []tss.PartyID{p1, p2, p3}, // All participants\n    Threshold: 1,                  // t (requires t+1 to sign)\n    Curve:     \"secp256k1\",        // Curve\n    SessionID: []byte(\"unique-session-id\"),\n}\n</code></pre>"},{"location":"USAGE/#key-generation-dkg","title":"Key Generation (DKG)","text":"<p>The KeyGen protocol generates a distributed private key. At the end, each party receives a <code>LocalPartySaveData</code> object containing their share.</p>"},{"location":"USAGE/#step-1-initialize-state-machine","title":"Step 1: Initialize State Machine","text":"<pre><code>import \"github.com/smallyu/go-cggmp-tss/internal/protocol/keygen\"\n\nstate, outMsgs, err := keygen.NewStateMachine(params)\nif err != nil {\n    panic(err)\n}\n\n// Send initial messages\nnetwork.Broadcast(outMsgs)\n</code></pre>"},{"location":"USAGE/#step-2-event-loop","title":"Step 2: Event Loop","text":"<p>Run the state machine until it finishes.</p> <pre><code>for {\n    // 1. Receive a message from the network\n    msg := network.Receive()\n\n    // 2. Update the state machine\n    nextState, outMsgs, err := state.Update(msg)\n    if err != nil {\n        panic(err)\n    }\n\n    // 3. Send output messages\n    for _, m := range outMsgs {\n        if m.IsBroadcast() {\n            network.Broadcast(m)\n        } else {\n            network.SendTo(m.To(), m)\n        }\n    }\n\n    // 4. Check if finished\n    if nextState == nil {\n        // Protocol finished\n        break\n    }\n\n    // 5. Advance state\n    state = nextState\n}\n</code></pre>"},{"location":"USAGE/#step-3-save-result","title":"Step 3: Save Result","text":"<pre><code>result := state.Result()\nif result == nil {\n    panic(\"KeyGen failed\")\n}\n\nkeyData := result.(*keygen.LocalPartySaveData)\n// Save keyData to disk securely!\n</code></pre>"},{"location":"USAGE/#threshold-signing","title":"Threshold Signing","text":"<p>Signing requires the <code>LocalPartySaveData</code> from KeyGen and the hash of the message to sign.</p>"},{"location":"USAGE/#step-1-initialize-state-machine_1","title":"Step 1: Initialize State Machine","text":"<pre><code>import \"github.com/smallyu/go-cggmp-tss/internal/protocol/sign\"\n\nmsgHash := sha256.Sum256([]byte(\"hello world\"))\n\nstate, outMsgs, err := sign.NewStateMachine(params, keyData, msgHash[:])\nif err != nil {\n    panic(err)\n}\n\n// Send initial messages\nnetwork.Broadcast(outMsgs)\n</code></pre>"},{"location":"USAGE/#step-2-event-loop_1","title":"Step 2: Event Loop","text":"<p>The loop is identical to KeyGen.</p>"},{"location":"USAGE/#step-3-get-signature","title":"Step 3: Get Signature","text":"<pre><code>result := state.Result()\nif result == nil {\n    panic(\"Sign failed\")\n}\n\nsignature := result.(*sign.Signature)\nfmt.Printf(\"R: %x\\nS: %x\\n\", signature.R, signature.S)\n</code></pre>"},{"location":"USAGE/#key-refresh","title":"Key Refresh","text":"<p>Proactive security often involves refreshing the secret shares without changing the public key. This renders old shares useless.</p>"},{"location":"USAGE/#step-1-initialize-state-machine_2","title":"Step 1: Initialize State Machine","text":"<p>The <code>NewStateMachine</code> for refresh takes the <code>oldKeyData</code> as input.</p> <pre><code>import \"github.com/smallyu/go-cggmp-tss/internal/protocol/refresh\"\n\n// keyData is your result from KeyGen\nstate, outMsgs, err := refresh.NewStateMachine(params, keyData)\nif err != nil {\n    panic(err)\n}\n\n// Send initial messages\nnetwork.Broadcast(outMsgs)\n</code></pre>"},{"location":"USAGE/#step-2-event-loop_2","title":"Step 2: Event Loop","text":"<p>The loop is identical to KeyGen and Signing.</p>"},{"location":"USAGE/#step-3-get-result","title":"Step 3: Get Result","text":"<p>The result is a new <code>LocalPartySaveData</code> object.</p> <pre><code>result := state.Result()\nif result == nil {\n    panic(\"Refresh failed\")\n}\n\nnewKeyData := result.(*keygen.LocalPartySaveData)\n\n// IMPORTANT: The Public Key (X, Y) should match the old key data.\n// But the Secret Share (Xi) and other internal values will be different.\nif newKeyData.PublicKeyX.Cmp(keyData.PublicKeyX) != 0 {\n    panic(\"Public key mismatch!\")\n}\n\n// Overwrite the old keyData on disk\nsaveToDisk(newKeyData)\n</code></pre>"}]}