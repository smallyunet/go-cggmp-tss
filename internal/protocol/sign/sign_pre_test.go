package sign

import (
	"crypto/sha256"
	"testing"

	"github.com/smallyu/go-cggmp-tss/internal/protocol/keygen"
	"github.com/smallyu/go-cggmp-tss/pkg/tss"
)

func TestPreSignE2E(t *testing.T) {
	// 1. Run KeyGen first
	pIDs := []string{"1", "2", "3"}
	parties := make([]tss.PartyID, 3)
	for i, id := range pIDs {
		parties[i] = &MockPartyID{id: id}
	}

	keygenSMs := make([]tss.StateMachine, 3)
	outMsgs := make([][]tss.Message, 3)
	var err error

	for i := 0; i < 3; i++ {
		params := &tss.Parameters{
			PartyID:   parties[i],
			Parties:   parties,
			Threshold: 1,
			Curve:     "secp256k1",
			SessionID: []byte("test-session"),
		}
		keygenSMs[i], outMsgs[i], err = keygen.NewStateMachine(params)
		if err != nil {
			t.Fatalf("Failed to create keygen state machine: %v", err)
		}
	}

	route := func(sms []tss.StateMachine, outMsgs [][]tss.Message) ([]tss.StateMachine, [][]tss.Message) {
		allMsgs := []tss.Message{}
		for _, msgs := range outMsgs {
			allMsgs = append(allMsgs, msgs...)
		}
		newOutMsgs := make([][]tss.Message, 3)
		
		for i := 0; i < 3; i++ {
			if sms[i] == nil { continue } // Already finished
			
			for _, msg := range allMsgs {
				if msg.From().ID() == parties[i].ID() { continue }
				if !msg.IsBroadcast() {
					found := false
					for _, dest := range msg.To() {
						if dest.ID() == parties[i].ID() {
							found = true
							break
						}
					}
					if !found { continue }
				}
				
				next, newOut, err := sms[i].Update(msg)
				if err != nil {
					t.Fatalf("Party %d failed: %v", i, err)
				}
				sms[i] = next
				if newOut != nil {
					newOutMsgs[i] = append(newOutMsgs[i], newOut...)
				}
			}
		}
		return sms, newOutMsgs
	}

	// Run KeyGen rounds
	for r := 1; r <= 4; r++ {
		keygenSMs, outMsgs = route(keygenSMs, outMsgs)
	}

	// Collect KeyGen results
	keyData := make([]*keygen.LocalPartySaveData, 3)
	for i := 0; i < 3; i++ {
		res := keygenSMs[i].Result()
		if res == nil {
			t.Fatalf("KeyGen failed for party %d", i)
		}
		keyData[i] = res.(*keygen.LocalPartySaveData)
	}

	// 2. Run PreSign (Offline Phase)
	preSignSMs := make([]tss.StateMachine, 3)
	preSignOutMsgs := make([][]tss.Message, 3)
	
	for i := 0; i < 3; i++ {
		params := &tss.Parameters{
			PartyID:   parties[i],
			Parties:   parties,
			Threshold: 1,
			Curve:     "secp256k1",
			SessionID: []byte("test-session-presign"),
		}
		preSignSMs[i], preSignOutMsgs[i], err = NewPreSignStateMachine(params, keyData[i])
		if err != nil {
			t.Fatalf("Failed to create presign state machine: %v", err)
		}
	}

	// Run PreSign rounds (1, 2, 3, 4)
	// Round 4 in PreSign is the final round where it returns result
	for r := 1; r <= 4; r++ {
		preSignSMs, preSignOutMsgs = route(preSignSMs, preSignOutMsgs)
	}

	// Collect PreSign results
	preSignatures := make([]*PreSignature, 3)
	for i := 0; i < 3; i++ {
		res := preSignSMs[i].Result()
		if res == nil {
			t.Fatalf("PreSign failed for party %d", i)
		}
		preSig, ok := res.(*PreSignature)
		if !ok {
			t.Fatalf("Expected PreSignature result, got %T", res)
		}
		preSignatures[i] = preSig
	}

	// 3. Run Online Sign
	msg := []byte("hello world")
	hash := sha256.Sum256(msg)
	
	onlineSMs := make([]tss.StateMachine, 3)
	onlineOutMsgs := make([][]tss.Message, 3)
	
	for i := 0; i < 3; i++ {
		params := &tss.Parameters{
			PartyID:   parties[i],
			Parties:   parties,
			Threshold: 1,
			Curve:     "secp256k1",
			SessionID: []byte("test-session-online"),
		}
		onlineSMs[i], onlineOutMsgs[i], err = NewOnlineStateMachine(params, keyData[i], preSignatures[i], hash[:])
		if err != nil {
			t.Fatalf("Failed to create online state machine: %v", err)
		}
	}
	
	// Run Online rounds
	// Round 1 (Online): Broadcast s_i (already done in NewOnlineStateMachine)
	// Round 2 (Online): Receive s_i, verify
	
	// We need to route the initial messages generated by NewOnlineStateMachine
	onlineSMs, onlineOutMsgs = route(onlineSMs, onlineOutMsgs)
	
	// Collect Final Signatures
	for i := 0; i < 3; i++ {
		res := onlineSMs[i].Result()
		if res == nil {
			t.Fatalf("Online Sign failed for party %d", i)
		}
		sig, ok := res.(*Signature)
		if !ok {
			t.Fatalf("Expected Signature result, got %T", res)
		}
		if sig.R == nil || sig.S == nil {
			t.Fatalf("Invalid signature")
		}
	}
}
